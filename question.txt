1. webRTC로 연결된 peer A와 peer B가 브라우저에서 동시에 연속으로 새로고침 할 때, 연결 끊김 현상이 발생하여 고민하고 찾아보았다.
2. Perfect Negotiation 패턴과, onnegotiationneeded 메서드가 있다는 사실을 알게 되었다.
3. 그런데 나는 frontend 개발자라서, network를 잘 모른다.
4. webRTC의 onnegotiationneeded을 이용한 Perfect Negotiation 패턴이 하나도 이해가 안된다.
5. 첫번째 접속자 Peer A가 브라우저에 진입하고, 두번째 접속자 Peer B가 브라우저에 진입하면 impoliet가 offer를 보내는 방식으로 해라!
6. client(webpack, ESmodule), server(nodejs) 전체 코드를 단계별로 step을 아주 잘게 세분화해서 단계별로 코드를 작성하고, 아주 자세하고, 알기 쉽게, 이해하기 쉽게 설명해줘라!
7. 이래도 되나 싶을정도로 단계를 길게 나누고, 설명은 아주 쉽고 자세하게 해라! 내가 쉽게 이해할 수 있도록 단계별로 추가되는 코드량은 아주 적어야 한다!
8. "한 번에 딱 한 단계만", 코드 추가량을 최대한 적게 하면서 아주 쉽게 가르쳐줘라!
9. 내가 "다음 단계로 가자"고 하면, 그 때 다음 step으로 넘어가라.


1. 나는 현재 webRTC를 이용해서 2인용 웹게임을 만들고 있다.
2. 두 peer가 webRTC로 room에 연결되어 있다면, 서버에서는 수많은 room을 가질 수 있다.
3. client는 html, css, javascript(esmodule), webpack을 사용중이다.
4. server는 new WebSocket signaling 서버를 node로 만들어서 사용중이다.
5. webRTC로 연결된 두 peer 중 한 명이 브라우저에서 새고로침(F5) 하면 재연결이 잘 되고 있다.
6. 그런데 webRTC로 연결된 두 peer가 서로 새로고침(F5)을 난타하면, webRTC 연결이 끊어진다.
7. 새로고침을 서로 난타하면, 누가 offer를 보내야 할 지 몰라, sdp/cnadidate 충돌이 발생하고 있는 것으로 예상될 뿐이다.
8. 해결방법을 찾아 보던 중, Perfect Negotiation 패턴과, onnegotiationneeded 메서드가 있다는 사실을 알게 되었다.
9. 그런데 나는 frontend 개발자라서, network를 잘 모르고, Perfect Negotiation 패턴 원리가 전혀 이해가 안된다.
19. 내가 잘 모르니, client, server 전체코드를 단게별로 STEP을 나눠서 나에게 가르쳐줘라.
11. "한 번에 딱 한 단계만", 코드 추가량을 최대한 적게 하면서 아주 쉽게 가르쳐줘라!
12. 내가 "다음 단계로 가자"고 하면, 그 때 다음 step으로 넘어가라.

필수조건:
- signaling server에서 두 peer가 한 room에 메칭되면, 그 다음 접속한 peer는 새로운 room에 배정받아야 한다.
- 서버에 무수히 많은 room이 동시에 생기고 사라질 수 있기 때문에, 서버 코드는 서로 다른 peer들의 동시 접속, 동시 퇴장 관리에 신경써야 한다.
- 브라우저에 접속 버튼 없이, 두번째 peer가 브라우저 url 접속하는 순간 WebRTC연결을 시도해야 한다.
- 반드시 두번째 peer가 입장했을 때, Perfect Negotiation 관례에 따라 두 peer 중, 한 peer만, offer를 보내라.
- 내가 webRTC를 잘 모르니까, 반드시 모든 코드에 최대한 자세히 주석을 달아라!

핵심:
- 두 peer가 webRTC로 연결된 후, 둘 중에 한 Peer가 새로고침 하면, 다시 재연결 되어야 한다.
- 두 peer가 webRTC로 연결된 후, 두 peer가 새로고침(F5)를 서로 난타해도, 다시 재연결 되어야 한다.



- 두 peer가 webRTC로 연결된 후, 브라우저에서 새로고침 할 때 마다, signaling서버에 재연결을 위한 요청 비용이 발생하므로, 새로고침 시 signaling 서버의 Task는 최소화 시켜야 한다.





너는 개발을 아주 잘하는 선생님이다. 나는 개발을 전혀 모르는 학생이다. 이것이 우리의 역할이다.
너는 나에게 아주 쉽고 알기쉽게 잘 설명을 해줘야 하는 선생님 역할이다.
지금 나에게 닥친 난관을 설명해줄테니 나를 잘 가르쳐주세요! 선생님!

1. 저는 현재 webRTC를 이용해서 2인용 웹게임을 만들고 있어요.
2. client는 html, css, javascript(esmodule), webpack을 사용중이에요.
3. server는 node로 new WebSocket signaling 서버를 만들어서 사용중이에요.
4. webRTC로 연결된 두 peer 중 한 명이 브라우저에서 새고로침(F5) 하면 재연결이 잘 되고 있어요.
5. 그런데 webRTC로 연결된 두 peer가 서로 새로고침(F5)을 난타하면, webRTC 연결이 끊어져요.
6. 새로고침을 서로 난타하면, 누가 offer를 보내야 할 지 몰라, sdp/cnadidate 충돌이 발생하고 있는 것으로 예상될 뿐이에요.
7. 해결방법을 찾아 보던 중, Perfect Negotiation 패턴과, onnegotiationneeded 메서드가 있다는 사실을 알게 되었어요.
8. 그런데 나는 frontend 개발자라서, network를 잘 모르고, Perfect Negotiation 패턴 원리가 전혀 이해가 안되요.
9. 내가 잘 모르니, client, server 전체코드를 단게별로 STEP을 나눠서 나에게 가르쳐주세요.
10. 단계가 길어져도 좋으니, "한 번에 딱 한 단계만", 코드 추가량을 최대한 적게 하면서 아주 쉽게 가르쳐주세요!
11. 내가 "다음 단계로 가자"고 하면, 그 때 다음 step으로 넘어가주세요.

필수조건:
- 첫번째 접속한 Peer가 대기중이고, 두번째 접속한 Peer가 진입했을 때, offer를 보내야해요.
- 두 peer가 webRTC로 연결된 후, 둘 중에 한 Peer가 새로고침 하면, 다시 재연결 되어야해요.
- 두 peer가 webRTC로 연결된 후, 두 peer가 새로고침(F5)를 서로 난타해도, 다시 재연결 되어야해요.
- 두 peer가 webRTC로 연결된 후, 브라우저에서 새로고침 할 때 마다, signaling서버에 재연결을 위한 요청 비용이 발생하므로, 새로고침 시 signaling 서버의 Task는 최소화 시켜야 해요.
- 내가 webRTC를 잘 모르니까, 모든 코드에 아주 쉽고 자세한 주석을 꼭 첨부해주세요!


unzip "C:/Users/Administrator/Downloads/유즈맵.zip" -d "H:/Program Files (x86)/Warcraft III/install/Maps/유즈맵"

unzip "C:/Users/Administrator/Downloads/무한맵.zip" -d "H:/Program Files (x86)/Starcraft/Maps/무한맵"
