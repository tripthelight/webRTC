1. webRTC로 연결된 peer A와 peer B가 브라우저에서 동시에 연속으로 새로고침 할 때, 연결 끊김 현상이 발생하여 고민하고 찾아보았다.
2. Perfect Negotiation 패턴과, onnegotiationneeded 메서드가 있다는 사실을 알게 되었다.
3. 그런데 나는 frontend 개발자라서, network를 잘 모른다.
4. webRTC의 onnegotiationneeded을 이용한 Perfect Negotiation 패턴이 하나도 이해가 안된다.
5. 첫번째 접속자 Peer A가 브라우저에 진입하고, 두번째 접속자 Peer B가 브라우저에 진입하면 impoliet가 offer를 보내는 방식으로 해라!
6. client(webpack, ESmodule), server(nodejs) 전체 코드를 단계별로 step을 아주 잘게 세분화해서 단계별로 코드를 작성하고, 아주 자세하고, 알기 쉽게, 이해하기 쉽게 설명해줘라!
7. 이래도 되나 싶을정도로 단계를 길게 나누고, 설명은 아주 쉽고 자세하게 해라! 내가 쉽게 이해할 수 있도록 단계별로 추가되는 코드량은 아주 적어야 한다!
8. "한 번에 딱 한 단계만", 코드 추가량을 최대한 적게 하면서 아주 쉽게 가르쳐줘라!
9. 내가 "다음 단계로 가자"고 하면, 그 때 다음 step으로 넘어가라.


1. 나는 현재 webRTC를 이용해서 2인용 웹게임을 만들고 있다.
2. client는 html, css, javascript(esmodule), webpack을 사용중이다.
3. server는 node로 new WebSocket signaling 서버를 만들어서 사용중이다.
4. webRTC로 연결된 두 peer 중 한 명이 브라우저에서 새고로침(F5) 하면 재연결이 잘 되고 있다.
5. 그런데 webRTC로 연결된 두 peer가 서로 새로고침(F5)을 난타하면, webRTC 연결이 끊어진다.
6. 새로고침을 서로 난타하면, 누가 offer를 보내야 할 지 몰라, sdp/cnadidate 충돌이 발생하고 있는 것으로 예상될 뿐이다.
7. 해결방법을 찾아 보던 중, Perfect Negotiation 패턴과, onnegotiationneeded 메서드가 있다는 사실을 알게 되었다.
8. 그런데 나는 frontend 개발자라서, network를 잘 모르고, Perfect Negotiation 패턴 원리가 전혀 이해가 안된다.
9. 내가 잘 모르니, client, server 전체코드를 단게별로 STEP을 나눠서 나에게 가르쳐줘라.
10. "한 번에 딱 한 단계만", 코드 추가량을 최대한 적게 하면서 아주 쉽게 가르쳐줘라!
11. 내가 "다음 단계로 가자"고 하면, 그 때 다음 step으로 넘어가라.

필수조건:
- 첫번째 접속한 Peer가 대기중이고, 두번째 접속한 Peer가 진입했을 때, offer를 보내라.
- 두 peer가 webRTC로 연결된 후, 둘 중에 한 Peer가 새로고침 하면, 다시 재연결 되어야 한다.
- 두 peer가 webRTC로 연결된 후, 두 peer가 새로고침(F5)를 서로 난타해도, 다시 재연결 되어야 한다.
- 두 peer가 webRTC로 연결된 후, 브라우저에서 새로고침 할 때 마다, signaling서버에 재연결을 위한 요청 비용이 발생하므로, 새로고침 시 signaling 서버의 Task는 최소화 시켜야 한다.
- 원격 SDP가 설정되기 전에 도착한 ICE 후보를 잠시 큐에 넣었다가, setRemoteDescription이 끝난 뒤에 한 번에 추가해야 한다.
- 두 peer가 webRTC로 연결된 후, 둘 중에 한 Peer가 연속으로 새로고침 할 때, 짧은 시간 계속 연타하면 서버에 연속으로 접속되어 부담이 되니까, 재접속까지 delay가 있어야 한다.
- 동시 제안(glare) 시 polite 측은 "내 로컬 오퍼를 롤백"해서 원격 오퍼를 수용할 수 있어야 한다.
